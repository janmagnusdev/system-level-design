# Questions

## During the Tutorium/ Course
### Assignment 4, on 17.06.2024
- [ ] `accumulator`
  - [ ] Why can't we bind to the three ports and channel.write() here, so that all three ports receive the data?
  - Seems like Signal Channel only supports one port on each side, i.e., two in total. 
    - [ ] How to make port have 2 connections to channels, or stated differently, allow channel to be connected to two ports?
- [ ] `line-follower`
  - [ ] What time unit should be used for wait() in car, so for consuming e.get_timer()?
  - [ ] How is made sure that Car fires sensor data first?
  - [ ] The solution actually passes no time as well

### Assignment 5, on 17.06.2024
- [x] Exports in Practice?
  - Adapter, da ist immer ein Export gefragt
  - Port Channel Port; horizontales Level
  - Vertikale Ebene -> Exports; dieselbe Ebene also
  - Binding von Ports/ Exports in Bezug auf Hierarchien:
    - Ports:
      - Ports auf höherer Ebene
      - Channels
      - Exports auf derselben Ebene
    - Exports:
      - Exports at lower hierarchy levels
      - Channels
    - Auch auf Folie Nummer 141 zu finden!
- [x] Why bind the module to itself with `out(*this)`?
  - required, so that the exports are connected on both sides
  - [x] Warum müssen Export-Blöcke zwangsläufig an sich selbst gebindet werden, und wann spezifisch nicht?
  - [x] Und warum muss man das bei `Ports` nicht machen?
- [x] Adapter vs. Transactor
  - transactor is a specific type of adapter, which translates higher level interfaces to lower level and vice versa
- [ ] How does UART work?


### Assignments 6, on 24.06.2024
- Für diese Zeit erstmal nur Aufgabe 1 und 2a); der Rest kommt dann später
- [ ] Wie funktioniert TLM?
  - VHDL, FPGAs, IP Komponenten (Bussysteme), Code Fragmente die wir selbst machen wollen
  - Verilog und VHDL sind zu spezifisch, TLM abstrahiert vieles weg, was wir sonst nervig manuell machen müssen
- [ ] Der RAM hat in Assignment 6 eine Breite von 16, und der Datentyp ist `unsigned`, also `unsigned int`
  - Also haben wir einen 16 * sizeof(unsigned) Breiten RAM
  - Die Breite der Datentypen ist dabei frei definierbar, man könnte `unsigned` also durch arbitrary structs ersetzen

## From working on the Exercises outside the Course
### Assignment 5, on 17.06.2024
- [ ] what does wait() (wait call without parameters) actually do?
  - in this case, it waits for the next clock cycle, since we registered forward() on the clock posedge() event
- [ ] why do we need the `to_byte()` call?
- [ ] module vs. prim channel
  - [ ] sensor_fifo was a regular SystemC module - with exports
  - [ ] control_fifo however will be a primitive channel which we will implement ourselves
  - how do sensor_fifo and control_fifo differ now, really? Why should we write control_fifo as a primitive channel, when sensor_fifo is a normal module which is just as sufficient?
- [ ] How **can** the Synchronization be solved cleverly?
  - probably with events?
  - what synchronization, anyway?
- [ ] Why are the the local events like `sc_core::sc_event m_data_written_event;` not initialised somewhere? does SystemC do it automatically?

- Note: I would not be able to do anything of this without al the comments lying around - which is quite frustrating. This is very complex, and I can barely grasp the core ideas. Maybe I should have listened more in the lectures...

# Important Topics for Exam!
From Monday, 01. July 2024

- Lecture 9 - most important part
  - Fundamental Concepts
    - Visual Language - using Diagrams, be able to read them and (optionally) write them yourselves!
      - Draw up a sketch
    - Not asking about Code
  - Processes
    - `SC_METHOD` vs `SC_THREAD` vs `SC_CTHREAD`
      - When can we use `wait()`, when not?
      - List difference
      - Explain them
      - Situations to use one of them - what you can and could do with them
      - static vs. dynamic sensitivity
      - Why (does this exist? what do we use it for?) -> If I know an answer to that, it will be fine.
    - (Running a Simulation - Implementation)
      - More or less not relevant!
      - (Testbench Idea)
      - (Artificial Generation of Stimuli)
      - All of this is very general and not special to SLD
      - (Waveform trace)
    - Channels!
      - We use them a lot!
      - Types:
        - Important: sc_signal!, sc_buffer!, sc_fifo!
        - Possible: sc_semaphore, sc_mutex
        - (sc_clock) -> not really relevant
      - `SC_METHOD` can't use blocking calls - non-blocking calls must be used, which are *harder* to use!
    - Synchronization via Events
      - Vanishing Events! -> nobody listening currently, event disappears
    - Time in SystemC - VERY important
      - Types of Events: Immediate, Delta, Timed, Cancelling
      - Multiple Notifications - how do they cancel each other?
        - One of the most important slides!
      - Sensitivity and Dynamic - specify, but no explanation required
    - Aware, that different Accessors exist for different Contexts
    - SystemC Phases - VERY IMPORTANT
      - Elaboration, Initialization, Simulation!
      - Simulation Cycle/ Event-Driven Simulation! 
        - R, D and T sets
        - When does the simulation end?
      - Draw the diagram by hand & explain!
    - Evaluate/ Update Mechanism
      - Why are these needed? Why do they exist?
      - Concurrent Hardware, which runs at the same time
      - Is supposed to do everything simultaneously - one process after the other
      - This mechanism is there to pretend that they are running at the same time
      - Excellent question for better grades!
  - Losing time here is just plain bad. Having enough time to explain more - not having to think about this is important.
  - Learn principles, deduce the facts from the principles. But this lecture is required to **just know**.
- (Lecture 10 - CPP)
- Lecture 11 - (Data Types), Interfaces, Channels, Adapters
  - Data Types interesting, but specific; not as relevant
    - Resolution Table is important - X and Z state
  - SystemC Communication Concept!
    - Lecture 9 - Identify and name ports; but not further
    - Here, more about the mechanisms behind it
    - "This interface must match this interface"
    - "During Elaboration, this port must be bound to a channel"
  - Hierarchical Channels vs. Primitive Channels! Minimal Channels
    - Examples, where one is better than the other?
    - Interfaces
      - in and out
      - blocking and non-blocking
      - rest is not relevant
  - Putting It All Together Diagram
    - What happens between and in all these Elements?
    - Explain Mechanisms
    - No exact code - only principles
  - Idea of Adapters and Transactors
    - Good Opportunity to relate SystemC to first part of lecture
    - Step by Step to get to the target system
  - Exports
    - Closely linked to hierarchical Channels
    - They only make sense when using hierarchical Channels
      - So I must learn those first
    - Boundary of official interface
    - Export FIFO itself can break assumptions - seperate code from behaviour
    - Channel -> Exports
    - Modules -> Ports
  - Hierarchical Connections - Good Diagram! Explain all this using this diagram. Everything is in there.
    - Remove all the text - infer what is an export and what is a port, by direction of the arrow.
  - m:1, 1:n connections fact is interesting, but not relevant here - only at TLM its important
  - Primitive Channel - how does it use the update mechanism? Have a rough description of that
  - Done with basic SystemC - Data Types not important, much more interesting things to ask
- Lecture 12 - TLM Part 1
  - Map first half of lecture to second half - how are they connected? Talk about that here.
    - If I don't know it, say it, and skip to talk about things that I do know
  - SystemC Modelling Levels
    - Functional View, PV, Architecture View, etc.
    - Bus Protocol not needed - we don't do Bit-accurate things
    - We have TLM to avoid talking about this
    - TLM has a Payload, which is configured for the different Features
  - Aspects to be Modelled
    - Nice facts where we can think about
  - Transactions
    - Backwards path! Really important and there is an important usecase for that!
  - Socket
    - Initiator & Target Socket
    - Socket is Combination of Export & Port - Port for Forward Path, Export for Backward Path
  - Technically Speaking TLMs are Hierarchical Channels
  - Master - provide and require an Interface
  - Slave - e.g. RAM
  - Different kinds of sockets and various ways of using them!
    - Convenience Sockets - Table! What are their features?
    - Explain these facts and the rules - when would you use one or the other?
  - Basic Functionality
    - Direct Connection
    - Talk to the other end
    - Evolution of this system
    - Direct Binding - needs no channel 1:1
  - Typical Diagram: Multiple Slaves and Masters
    - (Multi Passthrough Target Socket)
    - Roles of Initiator and Targets
    - Multi-Sockets visually distinguishable
  - Timing: How do we get timing into our Bus Model?
    - Exclusion
    - Arbiter - Cycle Accurate for certain types of Busses
      - Different Arbitration Algorithms
      - Work only together with seperate arbitration process
    - How works exactly is not important
    - Exchange and Evolution - Change Parts and test
    - Comparison of TLM Views! Diagram - Nothing explains this better than this diagram. Important!
  - Blocking vs. Non-Blocking Transactions
    - Being aware, that it is present
    - Having multiple phases
    - Ideally: Why do we need multiple phases?!
    - Advanced Features of Busses
  - Cross Bar Bus Topology
    - Not important
    - Seperates Routing from Arbitration
    - Don't care about being able to draw
- Lecture 13 - TLM Part 2
- Lecture 14 - Software Refinement in SystemC
  - From OSI to System Model
    - What would this be in SpecC?
    - Refinement through models
    - We can do the modelling of the first part with SystemC, because SystemC has those tools!
  - Introduce Routers and Multiplexers
    - Explain the diagram - what is going on here?
    - What did we do, to get our Refinement Process done?
  - (ISS) - 100% unimportant

IMPORTANT: Kim also uploaded important SpecC and SLD things!

Actual Exam Dates: 
- 19.08. to 23.08.
- First Week of September 02.09., 05.09. or 06.09. (starting later)
- Repeating an Exam might be able at the end of September - getting ill & something like that
- Place: Somewhere at OFFIS
- Bring pre-filled exam form